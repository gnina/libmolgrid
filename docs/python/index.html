<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>libmolgrid Python documentation &mdash; molgrid  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> molgrid
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference external" href="../index#://">Home</a></li>
<li class="toctree-l1"><a class="reference external" href="../about#://">About</a></li>
<li class="toctree-l1"><a class="reference external" href="../docs.html#://">Docs Home</a></li>
<li class="toctree-l1"><a class="reference external" href="../tutorials#://">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">libmolgrid Python documentation</a><ul>
<li class="toctree-l2"><a class="reference external" href="../index#://">Home</a></li>
<li class="toctree-l2"><a class="reference external" href="../about#://">About</a></li>
<li class="toctree-l2"><a class="reference external" href="../docs.html#://">Docs Home</a></li>
<li class="toctree-l2"><a class="reference external" href="../tutorials#://">Tutorials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#python-docs">Python Docs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-molgrid.torch_bindings">molgrid.torch_bindings module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molgrid-module-classes">molgrid module classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-atomtyper-class">The <code class="docutils literal notranslate"><span class="pre">AtomTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-cartesiangrid-class">The <code class="docutils literal notranslate"><span class="pre">CartesianGrid</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-coordinateset-class">The <code class="docutils literal notranslate"><span class="pre">CoordinateSet</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-elementindextyper-class">The <code class="docutils literal notranslate"><span class="pre">ElementIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-example-class">The <code class="docutils literal notranslate"><span class="pre">Example</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-exampleprovider-class">The <code class="docutils literal notranslate"><span class="pre">ExampleProvider</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-exampleprovidersettings-class">The <code class="docutils literal notranslate"><span class="pre">ExampleProviderSettings</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-examplevec-class">The <code class="docutils literal notranslate"><span class="pre">ExampleVec</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-fileatommapper-class">The <code class="docutils literal notranslate"><span class="pre">FileAtomMapper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-filemappedelementtyper-class">The <code class="docutils literal notranslate"><span class="pre">FileMappedElementTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-filemappedgninatyper-class">The <code class="docutils literal notranslate"><span class="pre">FileMappedGninaTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-gninaindextyper-class">The <code class="docutils literal notranslate"><span class="pre">GninaIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-gninavectortyper-class">The <code class="docutils literal notranslate"><span class="pre">GninaVectorTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-gridmaker-class">The <code class="docutils literal notranslate"><span class="pre">GridMaker</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-nullindextyper-class">The <code class="docutils literal notranslate"><span class="pre">NullIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-pythoncallbackindextyper-class">The <code class="docutils literal notranslate"><span class="pre">PythonCallbackIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-pythoncallbackvectortyper-class">The <code class="docutils literal notranslate"><span class="pre">PythonCallbackVectorTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-quaternion-class">The <code class="docutils literal notranslate"><span class="pre">Quaternion</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-subsetatommapper-class">The <code class="docutils literal notranslate"><span class="pre">SubsetAtomMapper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-subsettedelementtyper-class">The <code class="docutils literal notranslate"><span class="pre">SubsettedElementTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-transform-class">The <code class="docutils literal notranslate"><span class="pre">Transform</span></code> class</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-molgrid">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">molgrid</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>libmolgrid Python documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="libmolgrid-python-documentation">
<h1>libmolgrid Python documentation<a class="headerlink" href="#libmolgrid-python-documentation" title="Permalink to this headline"></a></h1>
<div class="toctree-wrapper compound">
<ul class="current">
<li class="toctree-l1"><a class="reference external" href="../index#://">Home</a></li>
<li class="toctree-l1"><a class="reference external" href="../about#://">About</a></li>
<li class="toctree-l1"><a class="reference external" href="../docs.html#://">Docs Home</a></li>
<li class="toctree-l1"><a class="reference external" href="../tutorials#://">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">libmolgrid Python documentation</a><ul>
<li class="toctree-l2"><a class="reference external" href="../index#://">Home</a></li>
<li class="toctree-l2"><a class="reference external" href="../about#://">About</a></li>
<li class="toctree-l2"><a class="reference external" href="../docs.html#://">Docs Home</a></li>
<li class="toctree-l2"><a class="reference external" href="../tutorials#://">Tutorials</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#python-docs">Python Docs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-molgrid.torch_bindings">molgrid.torch_bindings module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#molgrid-module-classes">molgrid module classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-atomtyper-class">The <code class="docutils literal notranslate"><span class="pre">AtomTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-cartesiangrid-class">The <code class="docutils literal notranslate"><span class="pre">CartesianGrid</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-coordinateset-class">The <code class="docutils literal notranslate"><span class="pre">CoordinateSet</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-elementindextyper-class">The <code class="docutils literal notranslate"><span class="pre">ElementIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-example-class">The <code class="docutils literal notranslate"><span class="pre">Example</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-exampleprovider-class">The <code class="docutils literal notranslate"><span class="pre">ExampleProvider</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-exampleprovidersettings-class">The <code class="docutils literal notranslate"><span class="pre">ExampleProviderSettings</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-examplevec-class">The <code class="docutils literal notranslate"><span class="pre">ExampleVec</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-fileatommapper-class">The <code class="docutils literal notranslate"><span class="pre">FileAtomMapper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-filemappedelementtyper-class">The <code class="docutils literal notranslate"><span class="pre">FileMappedElementTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-filemappedgninatyper-class">The <code class="docutils literal notranslate"><span class="pre">FileMappedGninaTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-gninaindextyper-class">The <code class="docutils literal notranslate"><span class="pre">GninaIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-gninavectortyper-class">The <code class="docutils literal notranslate"><span class="pre">GninaVectorTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-gridmaker-class">The <code class="docutils literal notranslate"><span class="pre">GridMaker</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-nullindextyper-class">The <code class="docutils literal notranslate"><span class="pre">NullIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-pythoncallbackindextyper-class">The <code class="docutils literal notranslate"><span class="pre">PythonCallbackIndexTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-pythoncallbackvectortyper-class">The <code class="docutils literal notranslate"><span class="pre">PythonCallbackVectorTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-quaternion-class">The <code class="docutils literal notranslate"><span class="pre">Quaternion</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-subsetatommapper-class">The <code class="docutils literal notranslate"><span class="pre">SubsetAtomMapper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-subsettedelementtyper-class">The <code class="docutils literal notranslate"><span class="pre">SubsettedElementTyper</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-transform-class">The <code class="docutils literal notranslate"><span class="pre">Transform</span></code> class</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-molgrid">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
</section>
<section id="python-docs">
<h1>Python Docs<a class="headerlink" href="#python-docs" title="Permalink to this headline"></a></h1>
<section id="module-molgrid.torch_bindings">
<span id="molgrid-torch-bindings-module"></span><h2>molgrid.torch_bindings module<a class="headerlink" href="#module-molgrid.torch_bindings" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.torch_bindings.BatchedCoords2GridFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.torch_bindings.</span></span><span class="sig-name descname"><span class="pre">BatchedCoords2GridFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.BatchedCoords2GridFunction" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.autograd.function.Function</span></code></p>
<p>Layer for converting from coordinate and type tensors to a molecular grid using batched input</p>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.BatchedCoords2GridFunction.backward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.BatchedCoords2GridFunction.backward" title="Permalink to this definition"></a></dt>
<dd><p>Return Nx3 coordinate gradient and NxT type gradient</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.BatchedCoords2GridFunction.forward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gmaker</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radii</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.BatchedCoords2GridFunction.forward" title="Permalink to this definition"></a></dt>
<dd><p>coords are BxNx3, types are BxNxT, radii are BxN</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Coords2Grid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.torch_bindings.</span></span><span class="sig-name descname"><span class="pre">Coords2Grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gmaker</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Coords2Grid" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Convert coordinates/types/radii to a grid using the provided
GridMaker and grid center</p>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Coords2Grid.extra_repr">
<span class="sig-name descname"><span class="pre">extra_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Coords2Grid.extra_repr" title="Permalink to this definition"></a></dt>
<dd><p>Set the extra representation of the module</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Coords2Grid.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radii</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Coords2Grid.forward" title="Permalink to this definition"></a></dt>
<dd><p>Defines the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Coords2Grid.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#molgrid.torch_bindings.Coords2Grid.training" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Coords2GridFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.torch_bindings.</span></span><span class="sig-name descname"><span class="pre">Coords2GridFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Coords2GridFunction" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.autograd.function.Function</span></code></p>
<p>Layer for converting from coordinate and type tensors to a molecular grid</p>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Coords2GridFunction.backward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Coords2GridFunction.backward" title="Permalink to this definition"></a></dt>
<dd><p>Return Nx3 coordinate gradient and NxT type gradient</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Coords2GridFunction.forward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gmaker</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radii</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Coords2GridFunction.forward" title="Permalink to this definition"></a></dt>
<dd><p>coords are Nx3, types are NxT, radii are N</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Grid2CoordsGradientFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.torch_bindings.</span></span><span class="sig-name descname"><span class="pre">Grid2CoordsGradientFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Grid2CoordsGradientFunction" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.autograd.function.Function</span></code></p>
<p>Backwards pass of grid generation so can create graph of gradient calculation</p>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Grid2CoordsGradientFunction.backward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_types</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Grid2CoordsGradientFunction.backward" title="Permalink to this definition"></a></dt>
<dd><p>Return second order grid gradient</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.Grid2CoordsGradientFunction.forward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gmaker</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_gradient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.Grid2CoordsGradientFunction.forward" title="Permalink to this definition"></a></dt>
<dd><p>Return Nx3 coordinate gradient and NxT type gradient</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="molgrid.torch_bindings.MolDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.torch_bindings.</span></span><span class="sig-name descname"><span class="pre">MolDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.MolDataset" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.utils.data.dataset.Dataset</span></code></p>
<p>A pytorch mappable dataset for molgrid training files.</p>
<p>Initialize mappable MolGridDataset.
:param input(s): File name(s) of training example files
:param typers: A tuple of AtomTypers to use
:type typers: tuple
:param cache_structs: retain coordinates in memory for faster training
:param add_hydrogens: protonate molecules read using openbabel
:param duplicate_first: clone the first coordinate set to be paired with each of the remaining (receptor-ligand pairs)
:param make_vector_types: convert index types into one-hot encoded vector types
:param data_root: prefix for data files
:param recmolcache: precalculated molcache2 file for receptor (first molecule); if doesn’t exist, will look in data _root
:param ligmolcache: precalculated molcache2 file for ligand; if doesn’t exist, will look in data_root</p>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.torch_bindings.MolDataset.collateMolDataset">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">collateMolDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.MolDataset.collateMolDataset" title="Permalink to this definition"></a></dt>
<dd><p>collate_fn for use in torch.utils.data.Dataloader when using the MolDataset.
Returns lengths, centers, coords, types, radii, labels all padded to fit maximum size of batch</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.torch_bindings.make_grid_tensor">
<span class="sig-prename descclassname"><span class="pre">molgrid.torch_bindings.</span></span><span class="sig-name descname"><span class="pre">make_grid_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gridmaker</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.make_grid_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Create appropriately sized pytorch tensor of grid densities.  set_gpu_enabled can be used to control if result is located on the cpu or gpu</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.torch_bindings.tensor_as_grid">
<span class="sig-prename descclassname"><span class="pre">molgrid.torch_bindings.</span></span><span class="sig-name descname"><span class="pre">tensor_as_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.torch_bindings.tensor_as_grid" title="Permalink to this definition"></a></dt>
<dd><p>Return a Grid view of tensor t</p>
</dd></dl>

</section>
<section id="molgrid-module-classes">
<h2>molgrid module classes<a class="headerlink" href="#molgrid-module-classes" title="Permalink to this headline"></a></h2>
<section id="the-atomtyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">AtomTyper</span></code> class<a class="headerlink" href="#the-atomtyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.AtomTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">AtomTyper</span></span><a class="headerlink" href="#molgrid.AtomTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<p>Base class for all atom typers</p>
<p>Raises an exception
This class cannot be instantiated from Python</p>
</dd></dl>

</section>
<section id="the-cartesiangrid-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">CartesianGrid</span></code> class<a class="headerlink" href="#the-cartesiangrid-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.CartesianGrid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">CartesianGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(MGrid3f)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)arg3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)arg4</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CartesianGrid" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>Wrapper around grid of type G that imposes Cartesian coordinates.
Includes center and resolution and supports (eventually) interpolation.</p>
</div></blockquote>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::ManagedGrid&lt;float, 3ul&gt;,float3,float)</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CartesianGrid.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CartesianGrid)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float3</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CartesianGrid.center" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float3 center(libmolgrid::CartesianGrid&lt;libmolgrid::ManagedGrid&lt;float, 3ul&gt; &gt; {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CartesianGrid.grid">
<span class="sig-name descname"><span class="pre">grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CartesianGrid)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">MGrid3f</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CartesianGrid.grid" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::ManagedGrid&lt;float, 3ul&gt; grid(libmolgrid::CartesianGrid&lt;libmolgrid::ManagedGrid&lt;float, 3ul&gt; &gt; {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CartesianGrid.resolution">
<span class="sig-name descname"><span class="pre">resolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CartesianGrid)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CartesianGrid.resolution" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float resolution(libmolgrid::CartesianGrid&lt;libmolgrid::ManagedGrid&lt;float, 3ul&gt; &gt; {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-coordinateset-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">CoordinateSet</span></code> class<a class="headerlink" href="#the-coordinateset-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.CoordinateSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">CoordinateSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>A collection of typed atomic coordinates</p>
<p>Types may be specified either as an index or a dense vector.
Typically, only one type formated will be initialized although
a vector one-hot encoding of an index type can be created.</p>
</div></blockquote>
<p>/</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (object)arg2 [, (AtomTyper)arg3]) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,OpenBabel::OBMol* [,libmolgrid::AtomTyper])</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (Grid2f)arg2, (Grid1f)arg3, (Grid1f)arg4, (int)arg5) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,unsigned int)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (Grid2fCUDA)arg2, (Grid1fCUDA)arg3, (Grid1fCUDA)arg4, (int)arg5) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,unsigned int)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (Grid2f)arg2, (Grid2f)arg3, (Grid1f)arg4) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (Grid2fCUDA)arg2, (Grid2fCUDA)arg3, (Grid1fCUDA)arg4) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (CoordinateSet)rec, (CoordinateSet)lig [, (bool)unique_index_types=True]) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::CoordinateSet,libmolgrid::CoordinateSet [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float3</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.center" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float3 center(libmolgrid::CoordinateSet {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">CoordinateSet</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.clone" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::CoordinateSet clone(libmolgrid::CoordinateSet {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.coords">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coords</span></span><a class="headerlink" href="#molgrid.CoordinateSet.coords" title="Permalink to this definition"></a></dt>
<dd><p>coordinates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.copyTo">
<span class="sig-name descname"><span class="pre">copyTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid1f)arg3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid1f)arg4</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.copyTo" title="Permalink to this definition"></a></dt>
<dd><p>copy into coord/type/radii grids</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long copyTo(libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>copyTo( (CoordinateSet)arg1, (Grid2fCUDA)arg2, (Grid1fCUDA)arg3, (Grid1fCUDA)arg4) -&gt; int :</dt><dd><p>copy into coord/type/radii grids</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long copyTo(libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;)</p>
</dd>
</dl>
</dd>
<dt>copyTo( (CoordinateSet)arg1, (Grid2f)arg2, (Grid2f)arg3, (Grid1f)arg4) -&gt; int :</dt><dd><p>copy into coord/type/radii grids</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long copyTo(libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;)</p>
</dd>
</dl>
</dd>
<dt>copyTo( (CoordinateSet)arg1, (Grid2fCUDA)arg2, (Grid2fCUDA)arg3, (Grid1fCUDA)arg4) -&gt; int :</dt><dd><p>copy into coord/type/radii grids</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long copyTo(libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.has_indexed_types">
<span class="sig-name descname"><span class="pre">has_indexed_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.has_indexed_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>bool has_indexed_types(libmolgrid::CoordinateSet {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.has_vector_types">
<span class="sig-name descname"><span class="pre">has_vector_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.has_vector_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>bool has_vector_types(libmolgrid::CoordinateSet {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.make_vector_types">
<span class="sig-name descname"><span class="pre">make_vector_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)include_dummy_type=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(list)type_radii=[]</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.make_vector_types" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>convert index types to vector types in-place
&#64;param include_dummy_type - if true will create an additional type at end (has zero radii if type radii are provided is true)
&#64;param type_radii - if provided, convert radii array to be type indexed,</p>
</div></blockquote>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void make_vector_types(libmolgrid::CoordinateSet {lvalue} [,bool=False [,boost::python::list=[]]])</p>
</dd>
</dl>
</div></blockquote>
<p>make_vector_types( (CoordinateSet)arg1 [, (bool)include_dummy_type=False [, (FloatVec)type_radii=&lt;molgrid.molgrid.FloatVec object at 0x7f1eee500350&gt;]]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>convert index types to vector types in-place
&#64;param include_dummy_type - if true will create an additional type at end (has zero radii if type radii are provided is true)
&#64;param type_radii - if provided, convert radii array to be type indexed,</p>
</div></blockquote>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void make_vector_types(libmolgrid::CoordinateSet {lvalue} [,bool=False [,std::vector&lt;float, std::allocator&lt;float&gt; &gt;=&lt;molgrid.molgrid.FloatVec object at 0x7f1eee500350&gt;]])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.max_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_type</span></span><a class="headerlink" href="#molgrid.CoordinateSet.max_type" title="Permalink to this definition"></a></dt>
<dd><p>largest type index</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::CoordinateSet {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.radii">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">radii</span></span><a class="headerlink" href="#molgrid.CoordinateSet.radii" title="Permalink to this definition"></a></dt>
<dd><p>atomic radii</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.size" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int size(libmolgrid::CoordinateSet {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">src</span></span><a class="headerlink" href="#molgrid.CoordinateSet.src" title="Permalink to this definition"></a></dt>
<dd><p>file source of coordinates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.sum_types">
<span class="sig-name descname"><span class="pre">sum_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid1f)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.sum_types" title="Permalink to this definition"></a></dt>
<dd><p>sum types across atoms</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void sum_types(libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 1ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>sum_types( (CoordinateSet)arg1, (Grid1fCUDA)arg2) -&gt; None :</dt><dd><p>sum types across atoms</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void sum_types(libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 1ul, true&gt;)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.tocpu">
<span class="sig-name descname"><span class="pre">tocpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(bool)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.tocpu" title="Permalink to this definition"></a></dt>
<dd><p>set memory affinity to CPU</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void tocpu(libmolgrid::CoordinateSet {lvalue},bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.togpu">
<span class="sig-name descname"><span class="pre">togpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(bool)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.CoordinateSet.togpu" title="Permalink to this definition"></a></dt>
<dd><p>set memory affinity to GPU</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void togpu(libmolgrid::CoordinateSet {lvalue},bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.type_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type_index</span></span><a class="headerlink" href="#molgrid.CoordinateSet.type_index" title="Permalink to this definition"></a></dt>
<dd><p>indexed types</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.CoordinateSet.type_vector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type_vector</span></span><a class="headerlink" href="#molgrid.CoordinateSet.type_vector" title="Permalink to this definition"></a></dt>
<dd><p>vector types</p>
</dd></dl>

</dd></dl>

</section>
<section id="the-elementindextyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">ElementIndexTyper</span></code> class<a class="headerlink" href="#the-elementindextyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.ElementIndexTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">ElementIndexTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ElementIndexTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<p>Calculate element types</p>
<p>There are quite a few elements, so should probably run this through
an organic chem atom mapper that reduces to number of types.
The type id is the atomic number.  Any element with atomic number
greater than or equal to the specified max is assigned type zero.</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (int)arg2) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,int)</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ElementIndexTyper.get_atom_type_index">
<span class="sig-name descname"><span class="pre">get_atom_type_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ElementIndexTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ElementIndexTyper.get_atom_type_index" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;int, float&gt; get_atom_type_index(libmolgrid::ElementIndexTyper {lvalue},OpenBabel::OBAtom*)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ElementIndexTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ElementIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ElementIndexTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::ElementIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ElementIndexTyper.get_type_radii">
<span class="sig-name descname"><span class="pre">get_type_radii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ElementIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FloatVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ElementIndexTyper.get_type_radii" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;float, std::allocator&lt;float&gt; &gt; get_type_radii(libmolgrid::ElementIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ElementIndexTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ElementIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ElementIndexTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::ElementIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-example-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">Example</span></code> class<a class="headerlink" href="#the-example-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.Example">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">Example</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>A single example represented by its typed coordinates and label(s)</p>
</div></blockquote>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="molgrid.Example.coord_sets">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coord_sets</span></span><a class="headerlink" href="#molgrid.Example.coord_sets" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.Example.group">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">group</span></span><a class="headerlink" href="#molgrid.Example.group" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.has_index_types">
<span class="sig-name descname"><span class="pre">has_index_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(int)start=0</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.has_index_types" title="Permalink to this definition"></a></dt>
<dd><p>uses index typing</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>bool has_index_types(libmolgrid::Example {lvalue} [,unsigned int=0])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.has_vector_types">
<span class="sig-name descname"><span class="pre">has_vector_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(int)start=0</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.has_vector_types" title="Permalink to this definition"></a></dt>
<dd><p>uses vector typing</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>bool has_vector_types(libmolgrid::Example {lvalue} [,unsigned int=0])</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.Example.labels">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">labels</span></span><a class="headerlink" href="#molgrid.Example.labels" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.merge_coordinates">
<span class="sig-name descname"><span class="pre">merge_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(int)start=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)unique_index_types=True</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">CoordinateSet</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.merge_coordinates" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Combine all coordinate sets into one and return it.
All coordinate sets must have the same kind of typing.  The result is a copy of the input coordinates.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param start</dt>
<dd class="field-odd"><p>ignore coordinates sets prior to this index (default zero)</p>
</dd>
<dt class="field-even">param unique_indexed_types</dt>
<dd class="field-even"><p>if true, different coordinate sets will have unique, non-overlapping types</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::CoordinateSet merge_coordinates(libmolgrid::Example {lvalue} [,unsigned int=0 [,bool=True]])</p>
</dd>
</dl>
</div></blockquote>
<p>merge_coordinates( (Example)arg1, (Grid2f)coord, (Grid1f)type_index, (Grid1f)radius [, (int)start=0 [, (bool)unique_index_types=True]]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Combine all coordinate sets into one.
All coordinate sets must have index typing</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param coords</dt>
<dd class="field-odd"><p>combined coordinates</p>
</dd>
<dt class="field-even">param type_index</dt>
<dd class="field-even"><p>combined types</p>
</dd>
<dt class="field-odd">param radii</dt>
<dd class="field-odd"><p>combined radii</p>
</dd>
<dt class="field-even">param start</dt>
<dd class="field-even"><p>ignore coordinates sets prior to this index (default zero)</p>
</dd>
<dt class="field-odd">param unique_indexed_types</dt>
<dd class="field-odd"><p>if true, different coordinate sets will have unique, non-overlapping types</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void merge_coordinates(libmolgrid::Example {lvalue},libmolgrid::Grid&lt;float, 2ul, false&gt; {lvalue},libmolgrid::Grid&lt;float, 1ul, false&gt; {lvalue},libmolgrid::Grid&lt;float, 1ul, false&gt; {lvalue} [,unsigned int=0 [,bool=True]])</p>
</dd>
</dl>
</div></blockquote>
<p>merge_coordinates( (Example)arg1, (Grid2f)coord, (Grid2f)type_vector, (Grid1f)radius [, (int)start=0 [, (bool)unique_index_types=True]]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Combine all coordinate sets into one.
All coordinate sets must have vector typing</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param coords</dt>
<dd class="field-odd"><p>combined coordinates</p>
</dd>
<dt class="field-even">param type_index</dt>
<dd class="field-even"><p>combined types</p>
</dd>
<dt class="field-odd">param radii</dt>
<dd class="field-odd"><p>combined radii</p>
</dd>
<dt class="field-even">param start</dt>
<dd class="field-even"><p>ignore coordinates sets prior to this index (default zero)</p>
</dd>
<dt class="field-odd">param unique_indexed_types</dt>
<dd class="field-odd"><p>if true, different coordinate sets will have unique, non-overlapping types</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void merge_coordinates(libmolgrid::Example {lvalue},libmolgrid::Grid&lt;float, 2ul, false&gt; {lvalue},libmolgrid::Grid&lt;float, 2ul, false&gt; {lvalue},libmolgrid::Grid&lt;float, 1ul, false&gt; {lvalue} [,unsigned int=0 [,bool=True]])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.num_coordinates">
<span class="sig-name descname"><span class="pre">num_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.num_coordinates" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long num_coordinates(libmolgrid::Example {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)unique_index_type=True</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long num_types(libmolgrid::Example {lvalue} [,bool=True])</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.Example.seqcont">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">seqcont</span></span><a class="headerlink" href="#molgrid.Example.seqcont" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.sum_types">
<span class="sig-name descname"><span class="pre">sum_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid1fCUDA)sum</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)unique_types=True</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.sum_types" title="Permalink to this definition"></a></dt>
<dd><p>sum types across atoms in coordinate sets</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void sum_types(libmolgrid::Example,libmolgrid::Grid&lt;float, 1ul, true&gt; [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>sum_types( (Example)arg1, (Grid1f)sum [, (bool)unique_types=True]) -&gt; None :</dt><dd><p>sum types across atoms in coordinate sets</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void sum_types(libmolgrid::Example,libmolgrid::Grid&lt;float, 1ul, false&gt; [,bool=True])</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.tocpu">
<span class="sig-name descname"><span class="pre">tocpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.tocpu" title="Permalink to this definition"></a></dt>
<dd><p>set memory affinity to CPU</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void tocpu(libmolgrid::Example {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Example.togpu">
<span class="sig-name descname"><span class="pre">togpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Example)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Example.togpu" title="Permalink to this definition"></a></dt>
<dd><p>set memory affinity to GPU</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void togpu(libmolgrid::Example {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-exampleprovider-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">ExampleProvider</span></code> class<a class="headerlink" href="#the-exampleprovider-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.ExampleProvider">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">ExampleProvider</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>Given a file of examples, provide Example classes one at a time
This contains an ExampleRefProvider, which can be configured using a
single settings object if so desired, and an example extractor.
Note that cache_structs is true by default which will load the entirety
of the dataset into memory.</p>
<p>An example files contains a single example on each line where an example
consists of some number of numerical labels (num_labels, will be auto-detected
if not specified) followed by file paths to molecular data, all space separated.</p>
</div></blockquote>
<p>/</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>object __init__(tuple args, dict kwds) :</dt><dd><p>Construct an ExampleProvider using an ExampleSettings object and the desired AtomTypers for each molecule.  Alternatively, specify individual settings using keyword arguments, where the keys correspond to properties of the ExampleProviderSettings class (please see that class for complete documentation of available settings).</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>object __init__(tuple args, dict kwds)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.get_large_epoch_num">
<span class="sig-name descname"><span class="pre">get_large_epoch_num</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.get_large_epoch_num" title="Permalink to this definition"></a></dt>
<dd><p>Return large epoch number, where an epoch means every example has been seen at LEAST once.</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long get_large_epoch_num(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.get_small_epoch_num">
<span class="sig-name descname"><span class="pre">get_small_epoch_num</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.get_small_epoch_num" title="Permalink to this definition"></a></dt>
<dd><p>Return small epoch number, where an epoch means every example has been seen at MOST once.</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long get_small_epoch_num(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.large_epoch_size">
<span class="sig-name descname"><span class="pre">large_epoch_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.large_epoch_size" title="Permalink to this definition"></a></dt>
<dd><p>Return size of large epoch</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long large_epoch_size(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Example</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.next" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::Example next(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.next_batch">
<span class="sig-name descname"><span class="pre">next_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(int)batch_size=0</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExampleVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.next_batch" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt; next_batch(libmolgrid::ExampleProvider {lvalue} [,unsigned int=0])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.num_labels">
<span class="sig-name descname"><span class="pre">num_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.num_labels" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long num_labels(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long num_types(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.populate">
<span class="sig-name descname"><span class="pre">populate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(str)file_name</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(int)num_labels=-1</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.populate" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void populate(libmolgrid::ExampleProvider {lvalue},std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; [,int=-1])</p>
</dd>
</dl>
</div></blockquote>
<p>populate( (ExampleProvider)arg1, (list)file_names [, (int)num_labels=-1]) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void populate(libmolgrid::ExampleProvider {lvalue},boost::python::list [,int=-1])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.reset" title="Permalink to this definition"></a></dt>
<dd><p>Reset iterator to beginning</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void reset(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.settings">
<span class="sig-name descname"><span class="pre">settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExampleProviderSettings</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.settings" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::ExampleProviderSettings settings(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.size" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long size(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleProvider.small_epoch_size">
<span class="sig-name descname"><span class="pre">small_epoch_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleProvider)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProvider.small_epoch_size" title="Permalink to this definition"></a></dt>
<dd><p>Return size of small epoch</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned long small_epoch_size(libmolgrid::ExampleProvider {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-exampleprovidersettings-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">ExampleProviderSettings</span></code> class<a class="headerlink" href="#the-exampleprovidersettings-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">ExampleProviderSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.add_hydrogens">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">add_hydrogens</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.add_hydrogens" title="Permalink to this definition"></a></dt>
<dd><p>protonate read in molecule using openbabel</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.balanced">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">balanced</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.balanced" title="Permalink to this definition"></a></dt>
<dd><p>provide equal number of positive and negative examples as determined by label</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.cache_structs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cache_structs</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.cache_structs" title="Permalink to this definition"></a></dt>
<dd><p>retain coordinates in memory for faster training</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.data_root">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_root</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.data_root" title="Permalink to this definition"></a></dt>
<dd><p>prefix for data files</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.default_batch_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_batch_size</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.default_batch_size" title="Permalink to this definition"></a></dt>
<dd><p>default batch size</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.duplicate_first">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">duplicate_first</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.duplicate_first" title="Permalink to this definition"></a></dt>
<dd><p>clone the first coordinate set to be paired with each of the remaining (receptor-ligand pairs)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.group_batch_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">group_batch_size</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.group_batch_size" title="Permalink to this definition"></a></dt>
<dd><p>slice time series (groups) by batches of this size</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.iteration_scheme">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iteration_scheme</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.iteration_scheme" title="Permalink to this definition"></a></dt>
<dd><p>Continuous, LargeEpoch, SmallEpoch</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>how to iterate over examples; note that the last batch may get padded with example from the next epoch. Options are</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.labelpos">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">labelpos</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.labelpos" title="Permalink to this definition"></a></dt>
<dd><p>position of binary label</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.ligmolcache">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ligmolcache</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.ligmolcache" title="Permalink to this definition"></a></dt>
<dd><p>precalculated molcache2 file for ligand; if doesn’t exist, will look in data_root</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.make_vector_types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">make_vector_types</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.make_vector_types" title="Permalink to this definition"></a></dt>
<dd><p>convert index types into one-hot encoded vector types</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.max_group_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_group_size</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.max_group_size" title="Permalink to this definition"></a></dt>
<dd><p>maximum group size, all groups are padded out to this size; example file must contain group number in first column</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.num_copies">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_copies</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.num_copies" title="Permalink to this definition"></a></dt>
<dd><p>number of times to repeatedly produce an example</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.recmolcache">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">recmolcache</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.recmolcache" title="Permalink to this definition"></a></dt>
<dd><p>precalculated molcache2 file for receptor (first molecule); if doesn’t exist, will look in data _root</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.shuffle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shuffle</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.shuffle" title="Permalink to this definition"></a></dt>
<dd><p>randomize order of examples</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.stratify_abs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stratify_abs</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.stratify_abs" title="Permalink to this definition"></a></dt>
<dd><p>stratify based on absolute value, for cases where negative has special meaning (e.g., hinge loss indicator)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.stratify_max">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stratify_max</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.stratify_max" title="Permalink to this definition"></a></dt>
<dd><p>maximum range for value stratification</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.stratify_min">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stratify_min</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.stratify_min" title="Permalink to this definition"></a></dt>
<dd><p>minimum range for value stratification</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.stratify_pos">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stratify_pos</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.stratify_pos" title="Permalink to this definition"></a></dt>
<dd><p>position of label for numerical stratification</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.stratify_receptor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stratify_receptor</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.stratify_receptor" title="Permalink to this definition"></a></dt>
<dd><p>sample uniformly across receptors (first molecule)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="molgrid.ExampleProviderSettings.stratify_step">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">stratify_step</span></span><a class="headerlink" href="#molgrid.ExampleProviderSettings.stratify_step" title="Permalink to this definition"></a></dt>
<dd><p>step size for value stratification, together with min and max determines number of bins</p>
</dd></dl>

</dd></dl>

</section>
<section id="the-examplevec-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">ExampleVec</span></code> class<a class="headerlink" href="#the-examplevec-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.ExampleVec">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">ExampleVec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleVec" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (list)arg2) -&gt; object :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void* __init__(boost::python::api::object,boost::python::list)</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleVec.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleVec)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleVec.append" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void append(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt; {lvalue},boost::python::api::object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleVec.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleVec)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleVec.extend" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void extend(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt; {lvalue},boost::python::api::object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleVec.extract_label">
<span class="sig-name descname"><span class="pre">extract_label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleVec)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(int)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid1f)arg3</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleVec.extract_label" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Extract a specific label from a vector of examples, as returned by ExampleProvider.next_batch.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param examples</dt>
<dd class="field-odd"><p>vector of examples</p>
</dd>
<dt class="field-even">param labelpos</dt>
<dd class="field-even"><p>position of label</p>
</dd>
<dt class="field-odd">param out</dt>
<dd class="field-odd"><p>1D grid (N)</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void extract_label(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,int,libmolgrid::Grid&lt;float, 1ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>extract_label( (ExampleVec)arg1, (int)arg2, (Grid1fCUDA)arg3) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Extract a specific label from a vector of examples, as returned by ExampleProvider.next_batch.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param examples</dt>
<dd class="field-odd"><p>vector of examples</p>
</dd>
<dt class="field-even">param labelpos</dt>
<dd class="field-even"><p>position of label</p>
</dd>
<dt class="field-odd">param out</dt>
<dd class="field-odd"><p>1D grid (N)</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void extract_label(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,int,libmolgrid::Grid&lt;float, 1ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleVec.extract_labels">
<span class="sig-name descname"><span class="pre">extract_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleVec)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleVec.extract_labels" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Extract labels from a vector of examples, as returned by ExampleProvider.next_batch.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param examples</dt>
<dd class="field-odd"><p>vector of examples</p>
</dd>
<dt class="field-even">param grid</dt>
<dd class="field-even"><p>2D grid (NxL)</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void extract_labels(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>extract_labels( (ExampleVec)arg1, (Grid2fCUDA)arg2) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Extract labels from a vector of examples, as returned by ExampleProvider.next_batch.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param examples</dt>
<dd class="field-odd"><p>vector of examples</p>
</dd>
<dt class="field-even">param grid</dt>
<dd class="field-even"><p>2D grid (NxL)</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void extract_labels(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.ExampleVec.sum_types">
<span class="sig-name descname"><span class="pre">sum_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(ExampleVec)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2fCUDA)sum</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)unique_types=True</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.ExampleVec.sum_types" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void sum_types(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,libmolgrid::Grid&lt;float, 2ul, true&gt; [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
<p>sum_types( (ExampleVec)arg1, (Grid2f)sum [, (bool)unique_types=True]) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void sum_types(std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,libmolgrid::Grid&lt;float, 2ul, false&gt; [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</dd></dl>

</section>
<section id="the-fileatommapper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">FileAtomMapper</span></code> class<a class="headerlink" href="#the-fileatommapper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.FileAtomMapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">FileAtomMapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(str)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(StringVec)arg3</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileAtomMapper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>Atom mappers <strong>************</strong>
Map atom types based on provided file.</p>
<p>Each line for the provided file specifies a single type.
Types are specified using type names.
This class must be provided the type names properly indexed (should match get_type_names).</p>
</div></blockquote>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;)</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileAtomMapper.get_new_type">
<span class="sig-name descname"><span class="pre">get_new_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileAtomMapper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(int)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileAtomMapper.get_new_type" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>int get_new_type(libmolgrid::FileAtomMapper {lvalue},unsigned int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileAtomMapper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileAtomMapper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileAtomMapper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::FileAtomMapper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileAtomMapper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileAtomMapper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileAtomMapper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::FileAtomMapper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-filemappedelementtyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">FileMappedElementTyper</span></code> class<a class="headerlink" href="#the-filemappedelementtyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.FileMappedElementTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">FileMappedElementTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(str)fname</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(int)maxe=84</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedElementTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; [,unsigned int=84])</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedElementTyper.get_atom_type_index">
<span class="sig-name descname"><span class="pre">get_atom_type_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedElementTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedElementTyper.get_atom_type_index" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;int, float&gt; get_atom_type_index(libmolgrid::FileMappedElementTyper {lvalue},OpenBabel::OBAtom*)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedElementTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedElementTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedElementTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::FileMappedElementTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedElementTyper.get_type_radii">
<span class="sig-name descname"><span class="pre">get_type_radii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedElementTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FloatVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedElementTyper.get_type_radii" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;float, std::allocator&lt;float&gt; &gt; get_type_radii(libmolgrid::FileMappedElementTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedElementTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedElementTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedElementTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::FileMappedElementTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-filemappedgninatyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">FileMappedGninaTyper</span></code> class<a class="headerlink" href="#the-filemappedgninatyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.FileMappedGninaTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">FileMappedGninaTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(str)fname</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)use_covalent_radius=False</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedGninaTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; [,bool=False])</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedGninaTyper.get_atom_type_index">
<span class="sig-name descname"><span class="pre">get_atom_type_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedGninaTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedGninaTyper.get_atom_type_index" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;int, float&gt; get_atom_type_index(libmolgrid::FileMappedGninaTyper {lvalue},OpenBabel::OBAtom*)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedGninaTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedGninaTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedGninaTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::FileMappedGninaTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedGninaTyper.get_type_radii">
<span class="sig-name descname"><span class="pre">get_type_radii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedGninaTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FloatVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedGninaTyper.get_type_radii" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;float, std::allocator&lt;float&gt; &gt; get_type_radii(libmolgrid::FileMappedGninaTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.FileMappedGninaTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(FileMappedGninaTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.FileMappedGninaTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::FileMappedGninaTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-gninaindextyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">GninaIndexTyper</span></code> class<a class="headerlink" href="#the-gninaindextyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.GninaIndexTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">GninaIndexTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaIndexTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<p>Atom typers <strong>************</strong>
Calculate gnina types</p>
<p>These are variants of AutoDock4 types.</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (bool)arg2) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,bool)</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GninaIndexTyper.get_atom_type_index">
<span class="sig-name descname"><span class="pre">get_atom_type_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GninaIndexTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaIndexTyper.get_atom_type_index" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;int, float&gt; get_atom_type_index(libmolgrid::GninaIndexTyper {lvalue},OpenBabel::OBAtom*)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GninaIndexTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GninaIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaIndexTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::GninaIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GninaIndexTyper.get_type_radii">
<span class="sig-name descname"><span class="pre">get_type_radii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GninaIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FloatVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaIndexTyper.get_type_radii" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;float, std::allocator&lt;float&gt; &gt; get_type_radii(libmolgrid::GninaIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GninaIndexTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GninaIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaIndexTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::GninaIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-gninavectortyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">GninaVectorTyper</span></code> class<a class="headerlink" href="#the-gninavectortyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.GninaVectorTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">GninaVectorTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaVectorTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<p>Decompose gnina types into elements and properties.  Result is boolean.</p>
<p>Hydrophobic, Aromatic, Donor, Acceptor</p>
<p>These are variants of AutoDock4 types.</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GninaVectorTyper.get_atom_type_vector">
<span class="sig-name descname"><span class="pre">get_atom_type_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GninaVectorTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaVectorTyper.get_atom_type_vector" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;boost::python::list, float&gt; get_atom_type_vector(libmolgrid::GninaVectorTyper,OpenBabel::OBAtom*)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GninaVectorTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GninaVectorTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaVectorTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::GninaVectorTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GninaVectorTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GninaVectorTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GninaVectorTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::GninaVectorTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-gridmaker-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">GridMaker</span></code> class<a class="headerlink" href="#the-gridmaker-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.GridMaker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">GridMaker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)resolution=0.5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)dimension=23.5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)binary=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)radius_type_indexed=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)radius_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)gaussian_radius_multiple=1.0</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>GridMaker
Populates a grid with atom density values that correspond to atoms in a
CoordinateSet and accumulates atomic gradients from the grid gradients.
It stores state about universal grid settings. In functions that map from
atomic coordinates to grids and vice versa (e.g. forward and backward), it
must be passed the grid_center (which may have changed due to
transformations performed directly on the atom coordinates externally to
this class)</p>
</div></blockquote>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object* [,float=0.5 [,float=23.5 [,bool=False [,bool=False [,float=1.0 [,float=1.0]]]]]])</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.backward">
<span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(CoordinateSet)arg3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid4f)arg4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg6</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.backward" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Generate atom and type gradients from grid gradients. (CPU)
Must provide atom coordinates that defined the original grid in forward
Vector types are required.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinate</dt>
<dd class="field-even"><p>set</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_gradients</dt>
<dd class="field-odd"><p>only set if input has type vectors</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (GridMaker)arg1, (float3)arg2, (CoordinateSet)arg3, (Grid4f)arg4, (Grid2f)arg5) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate atom gradients from grid gradients. (CPU)
Must provide atom coordinates that defined the original grid in forward
Index types are required</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinate</dt>
<dd class="field-even"><p>set</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (GridMaker)arg1, (float3)arg2, (CoordinateSet)arg3, (Grid4fCUDA)arg4, (Grid2fCUDA)arg5, (Grid2fCUDA)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate atom and type gradients from grid gradients. (GPU)
Must provide atom coordinates that defined the original grid in forward
Vector types are required.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinate</dt>
<dd class="field-even"><p>set</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_gradients</dt>
<dd class="field-odd"><p>only set if input has type vectors</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (GridMaker)arg1, (float3)arg2, (CoordinateSet)arg3, (Grid4fCUDA)arg4, (Grid2fCUDA)arg5) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate atom gradients from grid gradients. (GPU)
Must provide atom coordinates that defined the original grid in forward
Index types are required.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinate</dt>
<dd class="field-even"><p>set</p>
</dd>
<dt class="field-odd">param diff</dt>
<dd class="field-odd"><p>a 4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (GridMaker)arg1, (float3)arg2, (Grid2f)arg3, (Grid1f)arg4, (Grid1f)arg5, (Grid4f)arg6, (Grid2f)arg7) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate atom gradients from grid gradients. (CPU)
Must provide atom coordinates, types, and radii that defined the original grid in forward</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>indices (N integers stored as floats)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (GridMaker)arg1, (float3)arg2, (Grid2fCUDA)arg3, (Grid1fCUDA)arg4, (Grid1fCUDA)arg5, (Grid4fCUDA)arg6, (Grid2fCUDA)arg7) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate atom gradients from grid gradients. (GPU)
Must provide atom coordinates, types, and radii that defined the original grid in forward</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>indices (N integers stored as floats)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (GridMaker)arg1, (float3)arg2, (Grid2f)arg3, (Grid2f)arg4, (Grid1f)arg5, (Grid4f)arg6, (Grid2f)arg7, (Grid2f)arg8) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate atom and type gradients from grid gradients. (CPU)
Must provide atom coordinates, types, and radii that defined the original grid in forward</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (NxT)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_gradients</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (GridMaker)arg1, (float3)arg2, (Grid2fCUDA)arg3, (Grid2fCUDA)arg4, (Grid1fCUDA)arg5, (Grid4fCUDA)arg6, (Grid2fCUDA)arg7, (Grid2fCUDA)arg8) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate atom gradients from grid gradients. (GPU)
Must provide atom coordinates, types, and radii that defined the original grid in forward</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (NxT)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_gradients</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.backward_gradients">
<span class="sig-name descname"><span class="pre">backward_gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid1f)arg5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid4f)arg6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid4f)arg9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)arg11</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.backward_gradients" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Generate gradients of atom/type gradients. (CPU)
Must provide atom coordinates, types, and radii that defined the original grid in forward
and grid gradients from backward.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (NxT)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_gradients</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
<dt class="field-even">param diffdiff</dt>
<dd class="field-even"><p>a 4D grid of gradients of gradients</p>
</dd>
<dt class="field-odd">param atom_diffdiff</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
<dt class="field-even">param type_diffdiff</dt>
<dd class="field-even"><p>vector quantities for each atom*</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward_gradients(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward_gradients( (GridMaker)arg1, (float3)arg2, (Grid2fCUDA)arg3, (Grid2fCUDA)arg4, (Grid1fCUDA)arg5, (Grid4fCUDA)arg6, (Grid2fCUDA)arg7, (Grid2fCUDA)arg8, (Grid4fCUDA)arg9, (Grid2fCUDA)arg10, (Grid2fCUDA)arg11) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate gradients of atom/type gradients. (GPU)
Must provide atom coordinates, types, and radii that defined the original grid in forward
and grid gradients from backward.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (NxT)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid of gradients</p>
</dd>
<dt class="field-even">param atomic_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_gradients</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
<dt class="field-even">param diffdiff</dt>
<dd class="field-even"><p>a 4D grid of gradients of gradients</p>
</dd>
<dt class="field-odd">param atom_diffdiff</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
<dt class="field-even">param type_diffdiff</dt>
<dd class="field-even"><p>vector quantities for each atom*</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward_gradients(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward_gradients( (GridMaker)arg1, (float3)arg2, (CoordinateSet)arg3, (Grid4f)arg4, (Grid2f)arg5, (Grid2f)arg6, (Grid4f)arg7, (Grid2f)arg8, (Grid2f)arg9) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate gradients of atom/type gradients. (CPU)
Must provide CoordinateSet that defined the original grid in forward
and grid gradients from backward.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>coordinate set</p>
</dd>
<dt class="field-even">param a</dt>
<dd class="field-even"><p>4D grid of gradients</p>
</dd>
<dt class="field-odd">param atomic_gradients</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
<dt class="field-even">param type_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param diffdiff</dt>
<dd class="field-odd"><p>a 4D grid of gradients of gradients</p>
</dd>
<dt class="field-even">param atom_diffdiff</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_diffdiff</dt>
<dd class="field-odd"><p>vector quantities for each atom*</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward_gradients(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>backward_gradients( (GridMaker)arg1, (float3)arg2, (CoordinateSet)arg3, (Grid4fCUDA)arg4, (Grid2fCUDA)arg5, (Grid2fCUDA)arg6, (Grid4fCUDA)arg7, (Grid2fCUDA)arg8, (Grid2fCUDA)arg9) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate gradients of atom/type gradients. (GPU)
Must provide CoordinateSet that defined the original grid in forward
and grid gradients from backward.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>coordinate set</p>
</dd>
<dt class="field-even">param a</dt>
<dd class="field-even"><p>4D grid of gradients</p>
</dd>
<dt class="field-odd">param atomic_gradients</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
<dt class="field-even">param type_gradients</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param diffdiff</dt>
<dd class="field-odd"><p>a 4D grid of gradients of gradients</p>
</dd>
<dt class="field-even">param atom_diffdiff</dt>
<dd class="field-even"><p>vector quantities for each atom</p>
</dd>
<dt class="field-odd">param type_diffdiff</dt>
<dd class="field-odd"><p>vector quantities for each atom</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward_gradients(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 4ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Example)example</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid4f)grid</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)random_translation=0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)random_rotation=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.forward" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Generate CPU grid tensor from an example.
Coordinates may be optionally translated/rotated.  Do not use this function
if it is desirable to retain the transformation used (e.g., when backpropagating).
The center of the last coordinate set before transformation
will be used as the grid center.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>example</p>
</dd>
<dt class="field-even">param out</dt>
<dd class="field-even"><p>a 4D grid</p>
</dd>
<dt class="field-odd">param random_translation</dt>
<dd class="field-odd"><p>maximum amount to randomly translate each coordinate (+/-)</p>
</dd>
<dt class="field-even">param random_rotation</dt>
<dd class="field-even"><p>whether or not to randomly rotate</p>
</dd>
</dl>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Example,libmolgrid::Grid&lt;float, 4ul, false&gt; [,float=0.0 [,bool=False]])</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (Example)example, (Grid4fCUDA)grid [, (float)random_translation=0.0 [, (bool)random_rotation=False]]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate GPU grid tensor from an example.
Coordinates may be optionally translated/rotated.  Do not use this function
if it is desirable to retain the transformation used (e.g., when backpropagating).
The center of the last coordinate set before transformation
will be used as the grid center.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>example</p>
</dd>
<dt class="field-even">param out</dt>
<dd class="field-even"><p>a 4D grid</p>
</dd>
<dt class="field-odd">param random_translation</dt>
<dd class="field-odd"><p>maximum amount to randomly translate each coordinate (+/-)</p>
</dd>
<dt class="field-even">param random_rotation</dt>
<dd class="field-even"><p>whether or not to randomly rotate</p>
</dd>
</dl>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Example,libmolgrid::Grid&lt;float, 4ul, true&gt; [,float=0.0 [,bool=False]])</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (ExampleVec)examplevec, (Grid5f)grid [, (float)random_translation=0.0 [, (bool)random_rotation=False]]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from a vector of examples, as provided by ExampleProvider.next_batch.
Coordinates may be optionally translated/rotated.  Do not use this function
if it is desirable to retain the transformation used (e.g., when backpropagating).
The center of the last coordinate set before transformation
will be used as the grid center.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param example</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">param a</dt>
<dd class="field-even"><p>4D grid</p>
</dd>
<dt class="field-odd">param maximum</dt>
<dd class="field-odd"><p>amount to randomly translate each coordinate (+/-)</p>
</dd>
<dt class="field-even">param whether</dt>
<dd class="field-even"><p>or not to randomly rotate</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,libmolgrid::Grid&lt;float, 5ul, false&gt; [,float=0.0 [,bool=False]])</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (ExampleVec)examples, (Grid5fCUDA)grid [, (float)random_translation=0.0 [, (bool)random_rotation=False]]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from a vector of examples, as provided by ExampleProvider.next_batch.
Coordinates may be optionally translated/rotated.  Do not use this function
if it is desirable to retain the transformation used (e.g., when backpropagating).
The center of the last coordinate set before transformation
will be used as the grid center.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param example</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">param a</dt>
<dd class="field-even"><p>4D grid</p>
</dd>
<dt class="field-odd">param maximum</dt>
<dd class="field-odd"><p>amount to randomly translate each coordinate (+/-)</p>
</dd>
<dt class="field-even">param whether</dt>
<dd class="field-even"><p>or not to randomly rotate</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},std::vector&lt;libmolgrid::Example, std::allocator&lt;libmolgrid::Example&gt; &gt;,libmolgrid::Grid&lt;float, 5ul, true&gt; [,float=0.0 [,bool=False]])</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (float3)arg2, (CoordinateSet)arg3, (Grid4f)arg4) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from atomic data.  Grid (CPU) must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinate</dt>
<dd class="field-even"><p>set</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (float3)arg2, (CoordinateSet)arg3, (Grid4fCUDA)arg4) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from atomic data.  Grid (GPU) must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinate</dt>
<dd class="field-even"><p>set</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::CoordinateSet,libmolgrid::Grid&lt;float, 4ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (Example)arg2, (Transform)arg3, (Grid4f)arg4) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from an example while applying a transformation.
The center specified in the transform will be used as the grid center.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param example</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">param transformation</dt>
<dd class="field-even"><p>to apply</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Example,libmolgrid::Transform,libmolgrid::Grid&lt;float, 4ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (Example)arg2, (Transform)arg3, (Grid4fCUDA)arg4) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from an example while applying a transformation.
The center specified in the transform will be used as the grid center.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param example</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">param transformation</dt>
<dd class="field-even"><p>to apply</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Example,libmolgrid::Transform,libmolgrid::Grid&lt;float, 4ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (float3)arg2, (Grid2f)arg3, (Grid1f)arg4, (Grid1f)arg5, (Grid4f)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from CPU atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param indices</dt>
<dd class="field-odd"><p>(N integers stored as floats)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 4ul, false&gt; {lvalue})</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (float3)arg2, (Grid2fCUDA)arg3, (Grid1fCUDA)arg4, (Grid1fCUDA)arg5, (Grid4fCUDA)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from GPU atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param indices</dt>
<dd class="field-odd"><p>(N integers stored as floats)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 4ul, true&gt; {lvalue})</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (float3)arg2, (Grid2f)arg3, (Grid2f)arg4, (Grid1f)arg5, (Grid4f)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from CPU atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param vectors</dt>
<dd class="field-odd"><p>(NxT)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li><p>or (T)</p></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 1ul, false&gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (float3)arg2, (Grid2fCUDA)arg3, (Grid2fCUDA)arg4, (Grid1fCUDA)arg5, (Grid4fCUDA)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensor from GPU atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param center</dt>
<dd class="field-odd"><p>of grid</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(Nx3)</p>
</dd>
<dt class="field-odd">param vector</dt>
<dd class="field-odd"><p>indices (NxT)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><ol class="upperalpha simple" start="14">
<li><p>or (T) depending on if radii_type_indexed is set</p></li>
</ol>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>4D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},float3,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 1ul, true&gt;,libmolgrid::Grid&lt;float, 4ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (Grid2f)arg2, (Grid3f)arg3, (Grid2f)arg4, (Grid2f)arg5, (Grid5f)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensors from batched atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param centers</dt>
<dd class="field-odd"><p>of grid (Bx3)</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(BxNx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (BxNxT) or type indices (BxN)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><p>(BxN) or (BxT)</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>5D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 3ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 5ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (Grid2fCUDA)arg2, (Grid3fCUDA)arg3, (Grid2fCUDA)arg4, (Grid2fCUDA)arg5, (Grid5fCUDA)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensors from batched atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param centers</dt>
<dd class="field-odd"><p>of grid (Bx3)</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(BxNx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (BxNxT) or type indices (BxN)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><p>(BxN) or (BxT)</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>5D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 3ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 5ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (Grid2f)arg2, (Grid3f)arg3, (Grid3f)arg4, (Grid2f)arg5, (Grid5f)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensors from batched atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param centers</dt>
<dd class="field-odd"><p>of grid (Bx3)</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(BxNx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (BxNxT) or type indices (BxN)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><p>(BxN) or (BxT)</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>5D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 3ul, false&gt;,libmolgrid::Grid&lt;float, 3ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 5ul, false&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (GridMaker)arg1, (Grid2fCUDA)arg2, (Grid3fCUDA)arg3, (Grid3fCUDA)arg4, (Grid2fCUDA)arg5, (Grid5fCUDA)arg6) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Generate grid tensors from batched atomic data.  Grid must be properly sized.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param centers</dt>
<dd class="field-odd"><p>of grid (Bx3)</p>
</dd>
<dt class="field-even">param coordinates</dt>
<dd class="field-even"><p>(BxNx3)</p>
</dd>
<dt class="field-odd">param type</dt>
<dd class="field-odd"><p>vectors (BxNxT) or type indices (BxN)</p>
</dd>
<dt class="field-even">param radii</dt>
<dd class="field-even"><p>(BxN) or (BxT)</p>
</dd>
<dt class="field-odd">param a</dt>
<dd class="field-odd"><p>5D grid</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::GridMaker {lvalue},libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 3ul, true&gt;,libmolgrid::Grid&lt;float, 3ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 5ul, true&gt;)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.get_binary">
<span class="sig-name descname"><span class="pre">get_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.get_binary" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>bool get_binary(libmolgrid::GridMaker {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.get_dimension">
<span class="sig-name descname"><span class="pre">get_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.get_dimension" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float get_dimension(libmolgrid::GridMaker {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.get_radii_type_indexed">
<span class="sig-name descname"><span class="pre">get_radii_type_indexed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.get_radii_type_indexed" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>bool get_radii_type_indexed(libmolgrid::GridMaker {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.get_resolution">
<span class="sig-name descname"><span class="pre">get_resolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.get_resolution" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float get_resolution(libmolgrid::GridMaker {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.grid_dimensions">
<span class="sig-name descname"><span class="pre">grid_dimensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(int)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.grid_dimensions" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>boost::python::tuple grid_dimensions(libmolgrid::GridMaker {lvalue},int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.make_ndarray">
<span class="sig-name descname"><span class="pre">make_ndarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.GridMaker.make_ndarray" title="Permalink to this definition"></a></dt>
<dd><p>Create appropriately sized numpy array of grid densities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.make_tensor">
<span class="sig-name descname"><span class="pre">make_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.GridMaker.make_tensor" title="Permalink to this definition"></a></dt>
<dd><p>Create appropriately sized pytorch tensor of grid densities.  set_gpu_enabled can be used to control if result is located on the cpu or gpu</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.set_binary">
<span class="sig-name descname"><span class="pre">set_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(bool)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.set_binary" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_binary(libmolgrid::GridMaker {lvalue},bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.set_dimension">
<span class="sig-name descname"><span class="pre">set_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.set_dimension" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_dimension(libmolgrid::GridMaker {lvalue},float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.set_radii_type_indexed">
<span class="sig-name descname"><span class="pre">set_radii_type_indexed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(bool)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.set_radii_type_indexed" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_radii_type_indexed(libmolgrid::GridMaker {lvalue},bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.set_resolution">
<span class="sig-name descname"><span class="pre">set_resolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.set_resolution" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_resolution(libmolgrid::GridMaker {lvalue},float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.spatial_grid_dimensions">
<span class="sig-name descname"><span class="pre">spatial_grid_dimensions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(GridMaker)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.GridMaker.spatial_grid_dimensions" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>boost::python::tuple spatial_grid_dimensions(libmolgrid::GridMaker {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.GridMaker.tonumpy">
<span class="sig-name descname"><span class="pre">tonumpy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.GridMaker.tonumpy" title="Permalink to this definition"></a></dt>
<dd><p>Return a numpy array copy of grid g</p>
</dd></dl>

</dd></dl>

</section>
<section id="the-nullindextyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">NullIndexTyper</span></code> class<a class="headerlink" href="#the-nullindextyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.NullIndexTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">NullIndexTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.NullIndexTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<p>Always return an invalid type</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.NullIndexTyper.get_atom_type_index">
<span class="sig-name descname"><span class="pre">get_atom_type_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(NullIndexTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.NullIndexTyper.get_atom_type_index" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;int, float&gt; get_atom_type_index(libmolgrid::NullIndexTyper {lvalue},OpenBabel::OBAtom*)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.NullIndexTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(NullIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.NullIndexTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::NullIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.NullIndexTyper.get_type_radii">
<span class="sig-name descname"><span class="pre">get_type_radii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(NullIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FloatVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.NullIndexTyper.get_type_radii" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;float, std::allocator&lt;float&gt; &gt; get_type_radii(libmolgrid::NullIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.NullIndexTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(NullIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.NullIndexTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::NullIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-pythoncallbackindextyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">PythonCallbackIndexTyper</span></code> class<a class="headerlink" href="#the-pythoncallbackindextyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.PythonCallbackIndexTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">PythonCallbackIndexTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(int)num_types</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(list)names=[]</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackIndexTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,boost::python::api::object,unsigned int [,boost::python::list=[]])</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.PythonCallbackIndexTyper.get_atom_type_index">
<span class="sig-name descname"><span class="pre">get_atom_type_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(PythonCallbackIndexTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackIndexTyper.get_atom_type_index" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;int, float&gt; get_atom_type_index(PythonCallbackIndexTyper {lvalue},boost::python::api::object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.PythonCallbackIndexTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(PythonCallbackIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackIndexTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(PythonCallbackIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.PythonCallbackIndexTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(PythonCallbackIndexTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackIndexTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(PythonCallbackIndexTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-pythoncallbackvectortyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">PythonCallbackVectorTyper</span></code> class<a class="headerlink" href="#the-pythoncallbackvectortyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.PythonCallbackVectorTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">PythonCallbackVectorTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(int)num_types</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(list)names=[]</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackVectorTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,boost::python::api::object,unsigned int [,boost::python::list=[]])</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.PythonCallbackVectorTyper.get_atom_type_vector">
<span class="sig-name descname"><span class="pre">get_atom_type_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(PythonCallbackVectorTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackVectorTyper.get_atom_type_vector" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>boost::python::tuple get_atom_type_vector(PythonCallbackVectorTyper {lvalue},boost::python::api::object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.PythonCallbackVectorTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(PythonCallbackVectorTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackVectorTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(PythonCallbackVectorTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.PythonCallbackVectorTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(PythonCallbackVectorTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.PythonCallbackVectorTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(PythonCallbackVectorTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-quaternion-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">Quaternion</span></code> class<a class="headerlink" href="#the-quaternion-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.Quaternion">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">Quaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>A CUDA friendly quaternion class.  Single precision only
for maximum CUDA performance.</p>
</div></blockquote>
<p>/</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (float)arg2, (float)arg3, (float)arg4, (float)arg5) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,float,float,float,float)</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.R_component_1">
<span class="sig-name descname"><span class="pre">R_component_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.R_component_1" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float R_component_1(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.R_component_2">
<span class="sig-name descname"><span class="pre">R_component_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.R_component_2" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float R_component_2(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.R_component_3">
<span class="sig-name descname"><span class="pre">R_component_3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.R_component_3" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float R_component_3(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.R_component_4">
<span class="sig-name descname"><span class="pre">R_component_4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.R_component_4" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float R_component_4(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.conj">
<span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Quaternion</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.conj" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::Quaternion conj(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Quaternion</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.inverse" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::Quaternion inverse(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.norm" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float norm(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.real">
<span class="sig-name descname"><span class="pre">real</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.real" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float real(libmolgrid::Quaternion {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)z</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float3</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.rotate" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float3 rotate(libmolgrid::Quaternion {lvalue},float,float,float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Quaternion.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)arg3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)arg4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)arg5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)arg6</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float3</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Quaternion.transform" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float3 transform(libmolgrid::Quaternion {lvalue},float,float,float,float3,float3)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-subsetatommapper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">SubsetAtomMapper</span></code> class<a class="headerlink" href="#the-subsetatommapper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.SubsetAtomMapper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">SubsetAtomMapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(bool)arg3</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsetAtomMapper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>Map atom types onto a provided subset.</p>
</div></blockquote>
<p>/</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,std::vector&lt;int, std::allocator&lt;int&gt; &gt;,bool)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,std::vector&lt;std::vector&lt;int, std::allocator&lt;int&gt; &gt;, std::allocator&lt;std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; &gt;,bool)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3, (StringVec)arg4) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,std::vector&lt;int, std::allocator&lt;int&gt; &gt; {lvalue},bool,std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3, (StringVec)arg4) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,std::vector&lt;std::vector&lt;int, std::allocator&lt;int&gt; &gt;, std::allocator&lt;std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt; &gt; {lvalue},bool,std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (list)map [, (bool)catchall=True [, (StringVec)old_names=&lt;molgrid.molgrid.StringVec object at 0x7f1eee500200&gt;]]) -&gt; object :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void* __init__(boost::python::api::object,boost::python::list [,bool=True [,std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;=&lt;molgrid.molgrid.StringVec object at 0x7f1eee500200&gt;]])</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.SubsetAtomMapper.get_new_type">
<span class="sig-name descname"><span class="pre">get_new_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(SubsetAtomMapper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(int)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsetAtomMapper.get_new_type" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>int get_new_type(libmolgrid::SubsetAtomMapper {lvalue},unsigned int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.SubsetAtomMapper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(SubsetAtomMapper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsetAtomMapper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::SubsetAtomMapper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.SubsetAtomMapper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(SubsetAtomMapper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsetAtomMapper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::SubsetAtomMapper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-subsettedelementtyper-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">SubsettedElementTyper</span></code> class<a class="headerlink" href="#the-subsettedelementtyper-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.SubsettedElementTyper">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">SubsettedElementTyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(list)map</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)catchall=True</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(int)maxe=84</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsettedElementTyper" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#molgrid.AtomTyper" title="molgrid.molgrid.AtomTyper"><code class="xref py py-class docutils literal notranslate"><span class="pre">molgrid.molgrid.AtomTyper</span></code></a></p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void* __init__(boost::python::api::object,boost::python::list [,bool=True [,unsigned int=84]])</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.SubsettedElementTyper.get_atom_type_index">
<span class="sig-name descname"><span class="pre">get_atom_type_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(SubsettedElementTyper)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(object)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsettedElementTyper.get_atom_type_index" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::pair&lt;int, float&gt; get_atom_type_index(libmolgrid::SubsettedElementTyper {lvalue},OpenBabel::OBAtom*)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.SubsettedElementTyper.get_type_names">
<span class="sig-name descname"><span class="pre">get_type_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(SubsettedElementTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">StringVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsettedElementTyper.get_type_names" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt; get_type_names(libmolgrid::SubsettedElementTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.SubsettedElementTyper.get_type_radii">
<span class="sig-name descname"><span class="pre">get_type_radii</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(SubsettedElementTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">FloatVec</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsettedElementTyper.get_type_radii" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>std::vector&lt;float, std::allocator&lt;float&gt; &gt; get_type_radii(libmolgrid::SubsettedElementTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.SubsettedElementTyper.num_types">
<span class="sig-name descname"><span class="pre">num_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(SubsettedElementTyper)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.SubsettedElementTyper.num_types" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>unsigned int num_types(libmolgrid::SubsettedElementTyper {lvalue})</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="the-transform-class">
<h3>The <code class="docutils literal notranslate"><span class="pre">Transform</span></code> class<a class="headerlink" href="#the-transform-class" title="Permalink to this headline"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="molgrid.Transform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">Transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(object)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<blockquote>
<div><p>Stateful transformation of Cartesian coordinates.</p>
<blockquote>
<div><p>Stores a center of rotation, quaternion, and translation.
Can apply transformation forward or backward, with or without
translations.</p>
</div></blockquote>
</div></blockquote>
<p>/</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (Quaternion)arg2) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::Quaternion)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (Quaternion)arg2, (float3)arg3) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::Quaternion,float3)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (Quaternion)arg2, (float3)arg3, (float3)arg4) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,libmolgrid::Quaternion,float3,float3)</p>
</dd>
</dl>
</div></blockquote>
<p>__init__( (object)arg1, (float3)center [, (float)random_translate=0.0 [, (bool)random_rotation=False]]) -&gt; None :</p>
<blockquote>
<div><dl class="simple">
<dt>C++ signature :</dt><dd><p>void __init__(_object*,float3 [,float=0.0 [,bool=False]])</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.backward">
<span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)out</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)dotranslate=True</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.backward" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Apply inverse of 3D transformation on CPU.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>Nx3 input grid</p>
</dd>
<dt class="field-even">param out</dt>
<dd class="field-even"><p>Nx3 output grid (will be overwritten)</p>
</dd>
<dt class="field-odd">param dotranslate</dt>
<dd class="field-odd"><p>if false only the inverse rotation is applied</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::Transform {lvalue},libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt; [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
<p>backward( (Transform)arg1, (Grid2fCUDA)in, (Grid2fCUDA)out [, (bool)dotranslate=True]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Apply inverse of 3D transformation on GPU.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>Nx3 input grid</p>
</dd>
<dt class="field-even">param out</dt>
<dd class="field-even"><p>Nx3 output grid (will be overwritten)</p>
</dd>
<dt class="field-odd">param dotranslate</dt>
<dd class="field-odd"><p>if false only the inverse rotation is applied</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void backward(libmolgrid::Transform {lvalue},libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt; [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid2f)out</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(bool)dotranslate=True</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.forward" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Apply 3D transformation on CPU.   It is safe to transform
a grid in-place.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>Nx3 input grid</p>
</dd>
<dt class="field-even">param out</dt>
<dd class="field-even"><p>Nx3 output grid (will be overwritten)</p>
</dd>
<dt class="field-odd">param dotranslate</dt>
<dd class="field-odd"><p>if false only a rotation around the origin is applied.
(This is for vector quantities such as gradients and normals).</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::Transform {lvalue},libmolgrid::Grid&lt;float, 2ul, false&gt;,libmolgrid::Grid&lt;float, 2ul, false&gt; [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (Transform)arg1, (Grid2fCUDA)in, (Grid2fCUDA)out [, (bool)dotranslate=True]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Apply 3D transformation on GPU.  It is safe to transform a grid
in-place.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param in</dt>
<dd class="field-odd"><p>Nx3 input grid</p>
</dd>
<dt class="field-even">param out</dt>
<dd class="field-even"><p>Nx3 output grid (will be overwritten)</p>
</dd>
<dt class="field-odd">param dotranslate</dt>
<dd class="field-odd"><p>if false only a rotation around the origin is applied.
(This is for vector quantities such as gradients and normals).</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::Transform {lvalue},libmolgrid::Grid&lt;float, 2ul, true&gt;,libmolgrid::Grid&lt;float, 2ul, true&gt; [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (Transform)arg1, (CoordinateSet)in, (CoordinateSet)out [, (bool)dotranslate=True]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Apply 3D transformation to CoordinateSet.   It is safe to transform in-place</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param input</dt>
<dd class="field-odd"><p>coords</p>
</dd>
<dt class="field-even">param output</dt>
<dd class="field-even"><p>coords with same dimensions</p>
</dd>
<dt class="field-odd">param dotranslate</dt>
<dd class="field-odd"><p>if false only a rotation around the origin is applied.
(This is for vector quantities such as gradients and normals).</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::Transform {lvalue},libmolgrid::CoordinateSet,libmolgrid::CoordinateSet {lvalue} [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
<p>forward( (Transform)arg1, (Example)in, (Example)out [, (bool)dotranslate=True]) -&gt; None :</p>
<blockquote>
<div><blockquote>
<div><p>Apply 3D transformation to Example.   It is safe to transform in-place</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">param input</dt>
<dd class="field-odd"><p>example</p>
</dd>
<dt class="field-even">param output</dt>
<dd class="field-even"><p>example with same dimensions</p>
</dd>
<dt class="field-odd">param dotranslate</dt>
<dd class="field-odd"><p>if false only a rotation around the origin is applied.
(This is for vector quantities such as gradients and normals).</p>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void forward(libmolgrid::Transform {lvalue},libmolgrid::Example,libmolgrid::Example {lvalue} [,bool=True])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.get_quaternion">
<span class="sig-name descname"><span class="pre">get_quaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Quaternion</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.get_quaternion" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::Quaternion get_quaternion(libmolgrid::Transform {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.get_rotation_center">
<span class="sig-name descname"><span class="pre">get_rotation_center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float3</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.get_rotation_center" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float3 get_rotation_center(libmolgrid::Transform {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.get_translation">
<span class="sig-name descname"><span class="pre">get_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float3</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.get_translation" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>float3 get_translation(libmolgrid::Transform {lvalue})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.set_quaternion">
<span class="sig-name descname"><span class="pre">set_quaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Quaternion)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.set_quaternion" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_quaternion(libmolgrid::Transform {lvalue},libmolgrid::Quaternion)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.set_rotation_center">
<span class="sig-name descname"><span class="pre">set_rotation_center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.set_rotation_center" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_rotation_center(libmolgrid::Transform {lvalue},float3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="molgrid.Transform.set_translation">
<span class="sig-name descname"><span class="pre">set_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(Transform)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)arg2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.Transform.set_translation" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_translation(libmolgrid::Transform {lvalue},float3)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="module-molgrid">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-molgrid" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="molgrid.get_gpu_enabled">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">get_gpu_enabled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.get_gpu_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Get if generated grids are on GPU by default.</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>bool get_gpu_enabled()</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.read_dx">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">read_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(str)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">CartesianGrid</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.read_dx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Read in dx formatted grid and return initialized grid</p>
</div></blockquote>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>libmolgrid::CartesianGrid&lt;libmolgrid::ManagedGrid&lt;float, 3ul&gt; &gt; read_dx(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.read_dx_grids">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">read_dx_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(str)arg1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(StringVec)arg2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid4f)arg3</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.read_dx_grids" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Read multiple grids using type names as a suffix.  Grids must be correctly sized</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prefix</strong> – filename will have form [prefix]_[typename].dx</p></li>
<li><p><strong>names</strong> – must have same size as first dimension of grid</p></li>
<li><p><strong>grid</strong> – input grids</p></li>
</ul>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void read_dx_grids(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.set_gpu_enabled">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">set_gpu_enabled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(bool)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.set_gpu_enabled" title="Permalink to this definition"></a></dt>
<dd><p>Set if generated grids should be on GPU by default.</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_gpu_enabled(bool)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.set_random_seed">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">set_random_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(int)arg1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.set_random_seed" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void set_random_seed(long)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.tonumpy">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">tonumpy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#molgrid.tonumpy" title="Permalink to this definition"></a></dt>
<dd><p>Return a numpy array copy of grid g</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.write_dx">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">write_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(str)file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid3f)grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)resolution</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)scale=1.0</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.write_dx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>output grid as dx formatted file
Values are multiplied by scale, which may be necessary to adjust for limited precision in the text-based format</p>
</div></blockquote>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void write_dx(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,libmolgrid::Grid&lt;float, 3ul, false&gt;,float3,float [,float=1.0])</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.write_dx_grids">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">write_dx_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(str)prefix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(StringVec)type_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid4f)grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)resolution</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)scale=1.0</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.write_dx_grids" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Output multiple grids using type names as a suffix.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prefix</strong> – filename will have form [prefix]_[typename].dx</p></li>
<li><p><strong>names</strong> – must have same size as first dimension of grid</p></li>
<li><p><strong>grid</strong> – input grids</p></li>
<li><p><strong>center</strong> – </p></li>
<li><p><strong>resolution</strong> – </p></li>
<li><p><strong>scale</strong> – multiply each value by this factor</p></li>
</ul>
</dd>
</dl>
<p>/</p>
<dl class="simple">
<dt>C++ signature :</dt><dd><p>void write_dx_grids(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,std::vector&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;,libmolgrid::Grid&lt;float, 4ul, false&gt;,float3,float [,float=1.0])</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="molgrid.write_map">
<span class="sig-prename descclassname"><span class="pre">molgrid.</span></span><span class="sig-name descname"><span class="pre">write_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(str)file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(Grid3f)grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float3)center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(float)resolution</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">(float)scale=1.0</span></span></em><span class="optional">]</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span> <span class="pre">:</span></span></span><a class="headerlink" href="#molgrid.write_map" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>C++ signature :</dt><dd><p>void write_map(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;,libmolgrid::Grid&lt;float, 3ul, false&gt;,float3,float [,float=1.0])</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2021, David Koes and Jocelyn Sunseri.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>